<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms & Data Structures Website</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<header>
    <h1>Algorithms & Data Structures</h1>
    <nav>
        <a href="#algorithms">Algorithms</a>
        <a href="#pseudocode">Pseudocode</a>
        <a href="#codes">Code Implementations</a>
    </nav>
</header>

<section id="algorithms" class="box">
    <h2>10 Algorithms</h2>
    <ol>
        <li>Bubble Sort</li>
        <li>Selection Sort</li>
        <li>Insertion Sort</li>
        <li>Merge Sort</li>
        <li>Quick Sort</li>
        <li>Linear Search</li>
        <li>Binary Search</li>
        <li>Breadth-First Search (BFS)</li>
        <li>Depth-First Search (DFS)</li>
        <li>Fibonacci Algorithm</li>
    </ol>
</section>

<section id="pseudocode" class="box">
    <h2>10 Pseudocode</h2>
    <pre>
1. BUBBLE SORT
FOR i = 0 TO n-1
    FOR j = 0 TO n-i-1
        IF A[j] > A[j+1]
            SWAP A[j], A[j+1]

2. SELECTION SORT
FOR i = 0 TO n-1
    min = i
    FOR j = i+1 TO n
        IF A[j] < A[min]
            min = j
    SWAP A[i], A[min]

3. INSERTION SORT
FOR i = 1 TO n
    key = A[i]
    j = i - 1
    WHILE j >= 0 AND A[j] > key
        A[j+1] = A[j]
        j = j - 1
    A[j+1] = key

4. MERGE SORT
FUNCTION mergesort(A)
    IF size <= 1 RETURN A
    mid = size/2
    L = mergesort(left half)
    R = mergesort(right half)
    RETURN merge(L, R)

5. QUICK SORT
FUNCTION quicksort(A, low, high)
    IF low < high
        pivot = partition(A, low, high)
        quicksort(A, low, pivot-1)
        quicksort(A, pivot+1, high)

6. LINEAR SEARCH
FOR i = 0 TO n
    IF A[i] == key RETURN i

7. BINARY SEARCH
low = 0, high = n
WHILE low <= high
    mid = (low+high)/2
    IF key == A[mid] RETURN mid
    ELSE IF key < A[mid] high = mid-1
    ELSE low = mid+1

8. BFS
QUEUE q
ENQUEUE(start)
WHILE q not empty
    node = dequeue()
    FOR each neighbor of node
        IF not visited
            mark visited
            enqueue(neighbor)

9. DFS
FUNCTION DFS(node)
    mark visited
    FOR each neighbor
        IF not visited DFS(neighbor)

10. FIBONACCI
a = 0, b = 1
FOR i = 2 TO n
    temp = a + b
    a = b
    b = temp
RETURN b
    </pre>
</section>

<section id="codes" class="box">
    <h2>Data Structure Implementations</h2>

    <h3>Python Implementations</h3>
    <pre>
# ARRAY
arr = [1,2,3]
arr.append(4)
arr.pop(1)
print(arr)

# STACK (INFIX TO POSTFIX)
def precedence(op):
    if op in "+-": return 1
    if op in "*/": return 2
    return 0

def infix_to_postfix(expr):
    stack = []
    output = ""
    for c in expr:
        if c.isalnum():
            output += c
        elif c == '(':
            stack.append(c)
        elif c == ')':
            while stack[-1] != '(':
                output += stack.pop()
            stack.pop()
        else:
            while stack and precedence(stack[-1]) >= precedence(c):
                output += stack.pop()
            stack.append(c)

    while stack:
        output += stack.pop()

    return output

print(infix_to_postfix("A+B*C"))

# QUEUE
from collections import deque
q = deque()
q.append(1)
q.append(2)
q.popleft()
print(q)

# TREE TRAVERSALS
class Node:
    def __init__(self,val):
        self.val=val
        self.left=None
        self.right=None

def inorder(n):
    if n: 
        inorder(n.left)
        print(n.val)
        inorder(n.right)

def preorder(n):
    if n:
        print(n.val)
        preorder(n.left)
        preorder(n.right)

def postorder(n):
    if n:
        postorder(n.left)
        postorder(n.right)
        print(n.val)
    </pre>

</section>

</body>
</html>
